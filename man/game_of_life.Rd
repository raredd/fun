% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gol.R
\name{game_of_life}
\alias{game_of_life}
\alias{gol}
\alias{play_gol}
\alias{plot.gol}
\title{Conway's Game of Life}
\usage{
play_gol(mat, gen = max(dim(mat)), rotate = TRUE, scale = FALSE,
  rules = c("conway", "highlife", "life_without_death", "day_and_night"))

\method{plot}{gol}(x, col, sleep = 0.1, ...)
}
\arguments{
\item{mat}{a \code{{0,1}} integer matrix}

\item{gen}{number of generations to simulate}

\item{rotate}{logical; neighbor calculator; see details}

\item{scale}{logical; neighbor scaling; see details}

\item{rules}{character string specifying the rule set to use; choices are
\code{'conway'}, \code{'life_without_death'}, and \code{'day_and_night'};
alternatively, a rule function can be given, see details}

\item{x}{\code{gol} object, the result of \code{play_gol}}

\item{col}{a vector of two or more colors if \code{scale} is \code{TRUE};
otherwise, a vector of length two with the colors for live and dead cells,
respectively}

\item{sleep}{length of pause between generations}

\item{...}{additional parameters passed to \code{\link[rawr]{waffle}} or
further to \code{\link{par}}; see details}
}
\description{
A simulation of cellular automaton devised by mathematician John Horton
Conway. The life cycle is determined by the initial state matrix,
\code{mat}, and will evolve for \code{gen} generations. \code{plot.gol}
loops through all generation states to display the evolution over time.
}
\details{
Conway's Game of Life, or Life, consists of a grid of cells which have two
states at initiation, alive or dead, represented by 1s and 0s, respectively.
The evolution of these cells is determined by the eight neighboring cells
according to the following rules which are applied simultaneously to each
cell:

\enumerate{
\item{Any live cell with fewer than two live neighbors dies, as if caused
by under-population.}
\item{Any live cell with two or three live neighbors lives on to the next
generation.}
\item{Any live cell with more than three live neighbors dies, as if by
over-population.}
\item{Any dead cell with exactly three live neighbors becomes a live cell,
as if by reproduction.}
}

This function has two methods to calculate the neighbors for individual
cells. The default method (\code{rotate = TRUE}) uses a matrix rotation and
is much faster than the looping method (\code{rotate = FALSE}).

If \code{scale} is \code{TRUE}, the neighbor count matrix is scaled to
\code{[0,1]} giving a smoother distribution of the neighbor count. This is
useful when \code{col} is given as a vector of three or more colors which
is interpolated via \code{\link{colorRampPalette}}.

The resulting plot is created with \code{\link[rawr]{waffle}}, a non
exported function which can be accessed using \code{fun:::waffle}. Full
documentation and usage can be found in the \pkg{rawr} package version.

Four rule sets are built-in:
\enumerate{
\item{Conway (\code{"conway"}) - described above}
\item{Highlife (\code{"highlife"}) - similar to Conway with an additional
rule that dead cells with six neighbors are born}
\item{Life without death (\code{"life_without_death"}) - Conway's rules
without death}
\item{Day and night (\code{"day_and_night"}) - dead cells with 3, 6, 7,
or 8 neighbors are born, and alive cells with 3, 4, 6, 7, or 8 neighbors
survive}
}

Additionally, a custom rule function can be passed using the \code{rules}
argument. This function should have three arguments: an integer matrix
representing the current cell state, an integer matrix of the neighbor
count of these cells, and and integer representing the iteration count.
The function should apply a set of rules and return an integer matrix
having the same dimensions as the initial state.

Note that this function will be checked for input/output consistency
\emph{only}, so some or all of these parameters may be ignored as long as
this check passes; see examples.
}
\examples{
\dontrun{
set.seed(1)
n <- 150
m <- matrix(rbinom(n * n, 1, 0.3), n)
plot(play_gol(m))

plot(play_gol(m, rotate = TRUE, scale = TRUE),
     col = c('white', 'red', 'yellow', 'blue', 'white'))

## this system file contains some special cases
source(system.file('source', 'gol_special.R', package = 'fun'))

plot(play_gol(death))
plot(play_gol(rowof10))
plot(play_gol(big_exploder))
plot(play_gol(small_exploder))
plot(play_gol(glider, 50))
plot(play_gol(invader, 20))
plot(play_gol(tumbler))
plot(play_gol(glider_gun, 200))


## alternative rules
plot(play_gol(bowtie, 30, rules = 'highlife'))
plot(play_gol(ladder, rules = 'life_without_death'))
plot(play_gol(glider, 50, rules = 'day_and_night'))


## custom rules
my_rule <- function(X, ...) {
  x <- c(X)
  y <- fun:::rotate_(X, FALSE)
  x[sample(seq_along(x), max(y))] <- 0  ## kill random cells
  matrix(x, nrow(X))
}
plot(play_gol(matrix(1, 10, 10), 50, rules = my_rule))


## rule using time (current iteration)
my_rule <- function(X, Y, Z) {
  x <- c(X)
  y <- fun:::rotate_(X, FALSE)
  z <- Z \%\% 5 == 0L
  x[sample(seq_along(x), max(y))] <- 0  ## kill random cells
  x[sample(seq_along(x), 5)]      <- 1  ## spontaneous combustion
  matrix(x, nrow(X))
}
plot(play_gol(matrix(1, 10, 10), 50, rules = my_rule))


## rule ignoring inputs
my_rule <- function(...) {
  x <- matrix(sample(c(..1)), nrow(..1))
  x[sample(seq.int(nrow(x)), 1), ] <- 0
  x
}
plot(play_gol(matrix(1, 10, 10), 20, rules = my_rule))

}

}
\references{
\url{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}
}
