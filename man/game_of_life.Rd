% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gol.R
\name{game_of_life}
\alias{game_of_life}
\alias{gol}
\alias{play_gol}
\alias{plot.gol}
\title{Conway's Game of Life}
\usage{
play_gol(mat, gen = max(dim(mat)), rotate = TRUE, scale = FALSE,
  rules = "conway")

\method{plot}{gol}(x, col, time = 0.1, ...)
}
\arguments{
\item{mat}{a \code{{0,1}} integer matrix}

\item{gen}{number of generations to simulate}

\item{rotate}{logical; neighbor calculator; see details}

\item{scale}{logical; neighbor scaling; see details}

\item{rules}{character string specifying the rule set to use; choices are
\code{'conway'}, \code{'life_without_death'}, and \code{'day_and_night'};
alternatively, a rule function can be given, see details}

\item{x}{\code{gol} object, the result of \code{play_gol}}

\item{col}{a vector of two or more colors if \code{scale} is \code{TRUE};
otherwise, a vector of length two with the colors for live and dead cells,
respectively}

\item{time}{length of pause between generations}

\item{...}{additional parameters passed to \code{\link[rawr]{waffle}} or
further to \code{\link{par}}; see details}
}
\description{
A simulation of cellular automaton devised by mathematician John Horton
Conway. The life cycle is determined by the initial state matrix,
\code{mat}, and will evolve for \code{gen} generations. \code{plot.gol}
loops through all generation states to display the evolution over time.
}
\details{
Conway's Game of Life, or Life, consists of a grid of cells which have two
states at initiation, alive or dead, represented by 1s and 0s, respectively.
The evolution of these cells is determined by the eight neighboring cells
according to the following rules which are applied simultaneously to each
cell:

\enumerate{
\item{Any live cell with fewer than two live neighbours dies, as if caused
by under-population.}
\item{Any live cell with two or three live neighbours lives on to the next
generation.}
\item{Any live cell with more than three live neighbours dies, as if by
over-population.}
\item{Any dead cell with exactly three live neighbours becomes a live cell,
as if by reproduction.}
}

This function has two methods to calculate the neighbors for individual
cells. The default method (\code{rotate = TRUE}) uses a matrix rotation and
is much faster than the looping method (\code{rotate = FALSE}).

If \code{scale} is \code{TRUE}, the neighbor count matrix is scaled to
\code{[0,1]} giving a smoother distribution of the neighbor count. This is
useful when \code{col} is given as a vector of three or more colors which
is converted to a continuous scale via \code{\link{colorRampPalette}}.

The resulting plot is created with \code{\link[rawr]{waffle}}, a non
exported function which can be accessed using \code{fun:::waffle}. Full
documentation and usage can be found in the \pkg{rawr} package version.

Additionally, a custom rule function can be passed using the \code{rules}
argument. This function should have three arguments: an integer matrix
representing the current cell state, an integer matrix of the neighbor
count of these cells, and and integer representing the iteration count.
The function should apply a set of rules and return an integer matrix
having the same dimensions as the initial state.

Note that this function will be checked for input/output consistency only,
so all some or all of these parameters may be ignored so long as the check
passes; see examples.
}
\examples{
\dontrun{

set.seed(1)
n <- 150
m <- matrix(rbinom(n * n, 1, 0.3), n)
plot(play_gol(m))

plot(play_gol(m, rotate = TRUE, scale = TRUE),
     col = c('white','red','yellow','blue','white'))

## this system file contains some special cases
source(system.file('source', 'gol_special.R', package = 'fun'))

plot(play_gol(death))
plot(play_gol(rowof10))
plot(play_gol(big_exploder))
plot(play_gol(small_exploder))
plot(play_gol(glider, 50))
plot(play_gol(invader, 20))
plot(play_gol(tumbler))
plot(play_gol(glider_gun, 200))

## alternative rules
plot(play_gol(ladder, rules = 'life_without_death'))
plot(play_gol(glider, 50, rules = 'day_and_night'))
plot(play_gol(bowtie, 30, rules = 'high_life'))


## custom rules
my_rule <- function(X, ...) {
  x <- c(X)
  y <- fun:::rotate_(X, FALSE)
  x[sample(seq_along(x), max(y))] <- 0  ## kill random cells
  matrix(x, nrow(X))
}
plot(play_gol(matrix(1, 10, 10), 50, rules = my_rule))


## rule using time (current iteration)
my_rule <- function(X, Y, Z) {
  x <- c(X)
  y <- fun:::rotate_(X, FALSE)
  z <- Z \%\% 5 == 0L
  x[sample(seq_along(x), max(y))] <- 0  ## kill random cells
  x[sample(seq_along(x), 5)]      <- 1  ## spontaneous combustion
  matrix(x, nrow(X))
}
plot(play_gol(matrix(1, 10, 10), 50, rules = my_rule))


## rule ignoring inputs
my_rule <- function(...) {
  x <- matrix(sample(c(..1)), nrow(..1))
  x[sample(seq.int(nrow(x)), 1), ] <- 0
  x
}
plot(play_gol(matrix(1, 10, 10), 20, rules = my_rule))

}

}
\references{
\url{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}
}

